### Spring的AOP的认识

AOP：Aspect Oriented Programming 面向切面编程

OOP：Object Oriented Programming 面向对象编程

 面向切面编程：基于OOP基础之上新的编程思想，OOP面向的主要对象是类，而AOP面向的主要对象是切面，在处理日志、安全管理、事务管理等方面有非常重要的作用。AOP是Spring中重要的核心点，虽然IOC容器没有依赖AOP，但是AOP提供了非常强大的功能，用来对IOC做补充。通俗点说的话就是在程序运行期间，将**某段代码动态切入**到**指定方法**的**指定位置**进行运行的这种编程方式。

#### 1、AOP的概念

##### 为什么要引入AOP?

我们更多的是想要在程序运行过程中动态的获取方法的名称及参数、结果等相关信息，此时可以通过使用**动态代理**的方式来进行实现。

##### AOP的核心概念及术语

- 切面（Aspect）: 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类基于模式的方式（schema-based approach）或者在普通类中以`@Aspect`注解（@AspectJ 注解方式）来实现。
- 连接点（Join point）: 在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。
- 通知（Advice）: 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。
- 切点（Pointcut）: 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。
- 引入（Introduction）: 声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean实现 `IsModified`接口， 以便简化缓存机制（在AspectJ社区，引入也被称为内部类型声明（inter））。
- 目标对象（Target object）: 被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。
- AOP代理（AOP proxy）:AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。
- 织入（Weaving）: 把切面连接到其它的应用程序类型或者对象上，并创建一个被被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ编译器）、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样，是在运行时完成织入的。

##### AOP的通知类型

- 前置通知（Before advice）: 在连接点之前运行但无法阻止执行流程进入连接点的通知（除非它引发异常）。
- 后置返回通知（After returning advice）:在连接点正常完成后执行的通知（例如，当方法没有抛出任何异常并正常返回时）。
- 后置异常通知（After throwing advice）: 在方法抛出异常退出时执行的通知。
- 后置通知（总会执行）（After (finally) advice）: 当连接点退出的时候执行的通知（无论是正常返回还是异常退出）。
- 环绕通知（Around Advice）:环绕连接点的通知，例如方法调用。这是最强大的一种通知类型，。环绕通知可以在方法调用前后完成自定义的行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束。

##### AOP的应用场景

- 日志管理
- 权限认证
- 安全检查
- 事务控制

### 2、Spring AOP的简单配置

**综上所述：在spring容器中，如果有接口，那么会使用jdk自带的动态代理，如果没有接口，那么会使用cglib的动态代理。动态代理的实现原理，后续会详细讲。**

##### 注意：

###### 1、切入点表达式

 在使用表达式的时候，除了之前的写法之外，还可以使用通配符的方式：

 *：

 1、匹配一个或者多个字符

 execution( public int com.zhy.inter.My*alculator.*(int,int))

 2、匹配任意一个参数，

 execution( public int com.zhy.inter.MyCalculator.*(int,*))

 3、只能匹配一层路径，如果项目路径下有多层目录，那么*只能匹配一层路径

 4、权限位置不能使用*，如果想表示全部权限，那么不写即可

 execution( * com.zhy.inter.MyCalculator.*(int,*))

 ..：

 1、匹配多个参数，任意类型参数

 execution( * com.zhy.inter.MyCalculator.*(..))

 2、匹配任意多层路径

 execution( * com.zhy..MyCalculator.*(..))

 在写表达式的时候，可以有N多种写法，但是有一种最偷懒和最精确的方式：

 最偷懒的方式：execution(* *(..)) 或者 execution(* *.*(..))

 最精确的方式：execution( public int com.zhy.inter.MyCalculator.add(int,int))

 除此之外，在表达式中还支持 &&、||、！的方式

 &&：两个表达式同时

 execution( public int com.zhy.inter.MyCalculator.*(..)) && execution(* *.*(int,int) )

 ||：任意满足一个表达式即可

 execution( public int com.zhy.inter.MyCalculator.*(..)) && execution(* *.*(int,int) )

 ！：只要不是这个位置都可以进行切入

 &&：两个表达式同时

 execution( public int com.zhy.inter.MyCalculator.*(..))

###### 2、通知方法的执行顺序

 在之前的代码中大家一直对通知的执行顺序有疑问，其实执行的结果并没有错，大家需要注意：

 1、正常执行：@Before--->@After--->@AfterReturning

 2、异常执行：@Before--->@After--->@AfterThrowing

###### 3、获取方法的详细信息

 在上面的案例中，我们并没有获取Method的详细信息，例如方法名、参数列表等信息，想要获取的话其实非常简单，只需要添加JoinPoint参数即可。

###### 4、spring对通过方法的要求

 spring对于通知方法的要求并不是很高，你可以任意改变方法的返回值和方法的访问修饰符，但是唯一不能修改的就是方法的参数，会出现参数绑定的错误，原因在于通知方法是spring利用反射调用的，每次方法调用得确定这个方法的参数的值。

###### 5、表达式的抽取

如果在实际使用过程中，多个方法的表达式是一致的话，那么可以考虑将切入点表达式抽取出来：

 a、随便生命一个没有实现的返回void的空方法

 b、给方法上标注@Potintcut注解

###### 6、环绕通知的使用

总结：环绕通知的执行顺序是优于普通通知的，具体的执行顺序如下：

环绕前置-->普通前置-->目标方法执行-->环绕正常结束/出现异常-->环绕后置-->普通后置-->普通返回或者异常。

但是需要注意的是，如果出现了异常，那么环绕通知会处理或者捕获异常，普通异常通知是接收不到的，因此最好的方式是在环绕异常通知中向外抛出异常。

###### 7、多切面运行的顺序

 如果有多个切面要进行执行，那么顺序是什么样的呢？

在spring中，默认是按照切面名称的字典顺序进行执行的，但是如果想自己改变具体的执行顺序的话，可以使用@Order注解来解决，数值越小，优先级越高。